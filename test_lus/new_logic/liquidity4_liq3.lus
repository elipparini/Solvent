
type functions = enum { dummy, pay_func };
type address = enum { a1, a2 };
node c4 (xa:address ; xn:int;f:functions;pay_func_amount:int;starting_w: int;starting_aw_1: int;starting_aw_2: int) returns();
(*@contract
    assume starting_w >= 0;
    assume starting_aw_1 >= 0;
assume starting_aw_2 >= 0;
*)
var contract_not_constructed: bool;
const starting_err : bool = false;
var w: int;
var w_0: int;
var aw_1: int;
var aw_2: int;
var aw_1_0: int;
var aw_2_0: int;
var err : bool;
var err_0 : bool;
var err_1 : bool;
let
    if (true -> pre contract_not_constructed) then

 if (false) then 
	w = (starting_w -> pre w);
	aw_1 = (starting_aw_1 -> pre aw_1);
	aw_2 = (starting_aw_2 -> pre aw_2);
	
	
	contract_not_constructed = true; else 
	w = (starting_w -> pre w);
	aw_1 = (starting_aw_1 -> pre aw_1);
	aw_2 = (starting_aw_2 -> pre aw_2);
	
	
	contract_not_constructed = false;
fi
elsif f = pay_func then
	
if (not(pay_func_amount<=((starting_w -> pre w)-1))) then err_0=true; else err_0=false; fi

if (not(pay_func_amount >= 0 and pay_func_amount <= (starting_w -> pre w))) then err_1=true; else err_1=err_0; fi
w_0 = (starting_w -> pre w) - pay_func_amount;
if (xa = a1) then
	aw_1_0 = (starting_aw_1 -> pre aw_1) + pay_func_amount;
	aw_2_0 = (starting_aw_2 -> pre aw_2);
else
	aw_1_0 = (starting_aw_1 -> pre aw_1);
	aw_2_0 = (starting_aw_2 -> pre aw_2) + pay_func_amount;
fi
 if (err_1) then 
	w = (starting_w -> pre w);
	aw_1 = (starting_aw_1 -> pre aw_1);
	aw_2 = (starting_aw_2 -> pre aw_2);
	
	
	contract_not_constructed = (true -> pre contract_not_constructed); else 
	w = w_0;
	aw_1 = aw_1_0;
	aw_2 = aw_2_0;
	
	
	contract_not_constructed = (true -> pre contract_not_constructed);
fi
else
	w = (starting_w -> pre w);
	aw_1 = (starting_aw_1 -> pre aw_1);
	aw_2 = (starting_aw_2 -> pre aw_2);
	err = (starting_err -> pre err);
	
fi
--%PROPERTY 
	(forall (xa_tx: address;)
		(not (xa_tx = a1 or xa_tx = a2) or (contract_not_constructed)) /* user is legit*/
		or
		exists (
				pay_func_amount_tx: int; /* exists args : calldataargs . */
				v_tx: int;  /* exists v : int .  */
				w_nx: int; w_0_nx: int; aw_1_nx: int; aw_2_nx: int; aw_1_0_nx: int; aw_2_0_nx: int; err_nx : bool; err_0_nx : bool; err_1_nx : bool; err_2_nx : bool; err_3_nx : bool; /* Next state vars */
		)
		(
			(   /* condition */
				not(err_nx)
			)
			and
			(		
		(if (not(pay_func_amount_tx<=(w-1))) then err_0_nx=true else err_0_nx=false)
		and ((if (not(pay_func_amount_tx >= 0 and pay_func_amount_tx <= w)) then err_1_nx=true else err_1_nx=err_0_nx) 
		and w_0_nx = w - pay_func_amount_tx and
		if (xa_tx = a1) then
			aw_1_0_nx = aw_1 + pay_func_amount_tx and
			aw_2_0_nx = aw_2
		else
			aw_1_0_nx = aw_1 and
			aw_2_0_nx = aw_2 + pay_func_amount_tx
		) and if (err_1_nx) then 
			w_nx = w and 
			aw_1_nx = aw_1
			and aw_2_nx = aw_2 and 
			true and 
			true else  
			w_nx = w_0_nx and 
			aw_1_nx = aw_1_0_nx
			and aw_2_nx = aw_2_0_nx and 
			true and 
			true
		)
		and
		err_nx = err_1_nx
		)
	);

tel
        