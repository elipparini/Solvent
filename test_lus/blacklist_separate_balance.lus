/* N user = 2*/


type address = enum { Blacklist, U1, U2 };

type balance_functions = enum { transfer, read };
type blacklist_functions = enum { dummy, receive, pay };

node balance(
    f:balance_functions; 
    starting_w_Blacklist: int; 
    starting_w_U1: int;
    starting_w_U2: int;
    sender: address;
    receiver: address;
    amount: int;
    )
     returns(
        w_Blacklist: int;
        w_U1: int;
        w_U2: int;
        reverted: bool;
        );
(*@contract
    assume starting_w_Blacklist >= 0;
    assume starting_w_U1 >= 0;
    assume starting_w_U2 >= 0;
*)

var w_Blacklist_0: int;
var w_U1_0: int;
var w_U2_0: int;
let 
if f = transfer then
    if amount <= 0 then
        w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
        w_U1_0 = (starting_w_U1 -> pre w_U1);
        w_U2_0 = (starting_w_U2-> pre w_U2);
        reverted = true;
    elsif sender = Blacklist then
        if (starting_w_Blacklist -> pre w_Blacklist) >= amount then
            w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist) - amount;
            w_U1_0 = (starting_w_U1 -> pre w_U1);
            w_U2_0 = (starting_w_U2-> pre w_U2);
            reverted = false;
        else
            w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
            w_U1_0 = (starting_w_U1 -> pre w_U1);
            w_U2_0 = (starting_w_U2-> pre w_U2);
            reverted = true;
        fi
    elsif sender = U1 then
        if (starting_w_U1 -> pre w_U1) >= amount then
            w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
            w_U1_0 = (starting_w_U1 -> pre w_U1) - amount;
            w_U2_0 = (starting_w_U2-> pre w_U2);
            reverted = false;
        else
            w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
            w_U1_0 = (starting_w_U1 -> pre w_U1);
            w_U2_0 = (starting_w_U2-> pre w_U2);
            reverted = true;
        fi
    elsif sender = U2 then
        if (starting_w_U2 -> pre w_U2) >= amount then
            w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
            w_U1_0 = (starting_w_U1 -> pre w_U1);
            w_U2_0 = (starting_w_U2-> pre w_U2) - amount;
            reverted = false;
        else
            w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
            w_U1_0 = (starting_w_U1 -> pre w_U1);
            w_U2_0 = (starting_w_U2-> pre w_U2);
            reverted = true;
        fi
    else
        w_Blacklist_0 = (starting_w_Blacklist -> pre w_Blacklist);
        w_U1_0 = (starting_w_U1 -> pre w_U1);
        w_U2_0 = (starting_w_U2-> pre w_U2) - amount;
        reverted = true;
    fi
    if receiver = Blacklist then
        w_Blacklist = w_Blacklist_0 + amount;
        w_U1 = w_U1_0;
        w_U2 = w_U2_0;
    elsif receiver = U1 then
        w_Blacklist = w_Blacklist_0;
        w_U1 = w_U1_0 + amount;
        w_U2 = w_U2_0;
    elsif receiver = U1 then
        w_Blacklist = w_Blacklist_0;
        w_U1 = w_U1_0;
        w_U2 = w_U2_0 + amount;
    else
        w_Blacklist = (starting_w_Blacklist -> pre w_Blacklist);
        w_U1 = (starting_w_U1 -> pre w_U1);
        w_U2 = (starting_w_U2-> pre w_U2);
        /* TODO check receiver is valid also here*/
    fi
else /* f = read , or dummy*/
    w_Blacklist = (starting_w_Blacklist -> pre w_Blacklist);
    w_U1 = (starting_w_U1 -> pre w_U1);
    w_U2 = (starting_w_U2-> pre w_U2);
fi
tel

  node blacklist (xa:address; xn:int; 
    f:blacklist_functions; amount:int; 
    starting_w: int; starting_w_U1: int; starting_w_U2: int;) returns();
  (*@contract
  assume starting_w >= 0;
  assume starting_w_U1 >= 0;
  assume starting_w_U2 >= 0;
  *)
  var w_Blacklist: int;
  var w_U1 : int;
  var w_U2 : int;
  var reverted : bool;
  let
    if f = receive then
        if ( (xa = U1 or xa = U2)  /* require user is legit */
                ) then        
            w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, xn);
        else
            w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, -1); /* find better way */
        fi
    elsif f = pay then
        if (not(xa = U1)  /* require (msg.sender!=1) */
                and (xa = U1 or xa = U2)  /* require user is legit */
                and (xn = 0)    /* not payable */
                and amount >= 0
                ) then        
            w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, Blacklist, xa, xn);
        else
            w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, -1); /* find better way */
        fi
    else /* dummy */            
        w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, -1); /* find better way */
    fi

    --%PROPERTY /* liquidity1_nonliquid */
    forall (xa_tx: address;)
        (
            not (xa_tx = U1 or xa_tx = U2) /* user is legit*/
        )
        or
    exists (
            xn_tx: int; amount_tx: int; f_tx: blacklist_functions;  /* Transition vars */
            w_Blacklist_nx: int; w_U1_nx: int; w_U2_nx: int; reverted_nx: bool; /* Next state vars */
            ) 
        (
        (   /* condition   (<tx>balance[xa] == balance[xa]  + balance) */
            (not(xa_tx = U1) or w_U1_nx = w_U1 + w_Blacklist)
            and 
            (not(xa_tx = U2) or w_U2_nx = w_U2 + w_Blacklist)
        )
        and (   /* step_trans */
            
            if f_tx = receive then
                if ( (xa_tx = U1 or xa_tx = U2)  /* require user is legit */
                        ) then        
                    w_Blacklist_nx, w_U1_nx, w_U2_nx, reverted_nx = balance(transfer, 10, 10, 10, xa, Blacklist, xn);
                else
                    w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, -1); /* find better way */
                fi
            elsif f = pay then
                if (not(xa = U1)  /* require (msg.sender!=1) */
                        and (xa = U1 or xa = U2)  /* require user is legit */
                        and (xn = 0)    /* not payable */
                        and amount >= 0
                        ) then        
                    w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, Blacklist, xa, xn);
                else
                    w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, -1); /* find better way */
                fi
            else /* dummy */            
                w_Blacklist, w_U1, w_U2, reverted = balance(transfer, 10, 10, 10, xa, Blacklist, -1); /* find better way */
            fi
        
        )
        );
    tel